#ifndef ARRAY_H
#define ARRAY_H

double fa(double x);
//Функция для получения знач лаб 8
//@param x
//@return значение функции fа(x) = pow(x, 2) * M_PI * cos(M_PI * x);

double* full_elements(double* ptr_array, int n);

//Заполнение массива
//@param ptr_array указатель на массив
//@param n размер массива
//@return указатель на заполненный массив

int put_elements(double* ptr_array, int n);
//
//*Печать элементов массива
//* @param ptr_array указатель на массив
//* @param n размер массива
//* @return количество выведенных элементов
//* /

double* calc_elements(double* ptr_array, int n);
///
//*Обработка элементов массива(лаб 11)
//* (округляет все элементы вверх)
//* @param ptr_array указатель на массив
//* @param n размер массива
//* @return указатель на обр массив
//* /

double sum_elements(double* ptr_array, int begin, int end, int n);
///
//*Вычисление суммы элементов массива[begin, end]
//* @param ptr_array указатель на массив
//* @param begin нач индекс(включительно)
//* @param end кон индекс(включительно)
//* @return сумма эл
//* /

int find_element(double* ptr_array, int n, double element);
///
//*Поиск элемента в массиве
//* @param ptr_array указатель на массив
//* @param n размер массива
//* @param element искомый элемент
//* @return индекс найденного элемента или - 1 если не найден
//* /

double max_abs(double* ptr_array, int n, double A);
//Поиск максимального по модулю значения, не равного заданному A
//
//@param ptr_array указатель на массив
//
//@param n размер массива
//
//@param A значение, которое нужно исключить из поиска
//
//@return максимальное значение модуля | x | среди элементов массива, не равных A;

int delete_negatives(double* ptr_arr, int size);
/**
 * Удаление всех отрицательных элементов массива
 * @param ptr_arr указатель на массив
 * @param size текущее количество элементов массива
 * @return новое количество элементов после удаления отрицательных
 *
 * Функция просматривает массив и «сжимает» его так,
 * чтобы в начале остались только элементы, не меньшие нуля.
 * Отрицательные значения пропускаются, физическое перераспределение
 * памяти не выполняется, изменяется только логический размер массива.
 */
double* insert(double* ptr_arr, int* size);
/**
 * Вставка значения -999 после каждого положительного элемента динамического массива
 * @param ptr_arr указатель на динамический массив чисел с плавающей запятой
 * @param size указатель на текущее количество элементов массива
 * @return указатель на измененный массив; исходный при ошибке выделения памяти
 *
 * Функция подсчитывает количество положительных элементов для определения нового размера,
 * расширяет память через realloc, затем последовательно копирует элементы исходного массива
 * в новый, вставляя -999.0 после каждого положительного элемента. Логический размер массива обновляется.
 */

double max_min_diff(double* ptr_array, int begin, int end, int n);
#endif
