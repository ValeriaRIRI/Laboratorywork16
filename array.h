#ifndef ARRAY_H
#define ARRAY_H

double fa(double x);
//Функция для получения знач лаб 8
//@param x
//@return значение функции fа(x) = pow(x, 2) * M_PI * cos(M_PI * x);

double* full_elements(double* ptr_array, int n);

//Заполнение массива
//@param ptr_array указатель на массив
//@param n размер массива
//@return указатель на заполненный массив

int put_elements(double* ptr_array, int n);
//
//*Печать элементов массива
//* @param ptr_array указатель на массив
//* @param n размер массива
//* @return количество выведенных элементов
//* /

double* calc_elements(double* ptr_array, int n);
///
//*Обработка элементов массива(лаб 11)
//* (округляет все элементы вверх)
//* @param ptr_array указатель на массив
//* @param n размер массива
//* @return указатель на обр массив
//* /

double sum_elements(double* ptr_array, int begin, int end, int n);
///
//*Вычисление суммы элементов массива[begin, end]
//* @param ptr_array указатель на массив
//* @param begin нач индекс(включительно)
//* @param end кон индекс(включительно)
//* @return сумма эл
//* /

int find_element(double* ptr_array, int n, double element);
///
//*Поиск элемента в массиве
//* @param ptr_array указатель на массив
//* @param n размер массива
//* @param element искомый элемент
//* @return индекс найденного элемента или - 1 если не найден
//* /

double max_abs(double* ptr_array, int n, double A);
//Поиск максимального по модулю значения, не равного заданному A
//
//@param ptr_array указатель на массив
//
//@param n размер массива
//
//@param A значение, которое нужно исключить из поиска
//
//@return максимальное значение модуля | x | среди элементов массива, не равных A;

int delete_negatives(double* ptr_arr, int size);
/**
 * Удаление всех отрицательных элементов массива
 * @param ptr_arr указатель на массив
 * @param size текущее количество элементов массива
 * @return новое количество элементов после удаления отрицательных
 *
 * Функция просматривает массив и «сжимает» его так,
 * чтобы в начале остались только элементы, не меньшие нуля.
 * Отрицательные значения пропускаются, физическое перераспределение
 * памяти не выполняется, изменяется только логический размер массива.
 */
double* insert(double* ptr_arr, int* size);
/**
 * Вставка значения -999 после каждого положительного элемента динамического массива
 * @param ptr_arr указатель на динамический массив чисел с плавающей запятой
 * @param size указатель на текущее количество элементов массива
 * @return указатель на измененный массив; исходный при ошибке выделения памяти
 *
 * Функция подсчитывает количество положительных элементов для определения нового размера,
 * расширяет память через realloc, затем последовательно копирует элементы исходного массива
 * в новый, вставляя -999.0 после каждого положительного элемента. Логический размер массива обновляется.
 */

double max_min_diff(double* ptr_array, int begin, int end, int n);

/**
 * Создание нового массива D из трех исходных массивов A, B, C
 * @param arr_a исходный массив A
 * @param arr_b исходный массив B
 * @param arr_c исходный массив C
 * @param size_a размер массива A
 * @param size_b размер массива B
 * @param size_c размер массива C
 * @param size_d указатель на размер результирующего массива D
 * @return указатель на динамический массив D
 *
 * Формирует массив D по правилам:
 * 1. Подсчитывает отрицательные элементы в A (neg)
 * 2. Вычисляет размер D: neg + size_b + ceil(size_c/5)
 * 3. Выделяет память под D
 *
 * Заполнение D (слева направо):
 * - Отрицательные из A (справа налево: arr_a[size_a-1] - arr_a[0])
 * - Все элементы из B (слева направо)
 * - Элементы из C с шагом 5: arr_c[0], arr_c[5], arr_c[10]...
 */
double* create_arr_d(double* arr_a, double* arr_b, double* arr_c, int size_a, int size_b, int size_c, int* size_d);

/**
 * Генерация случайного массива double заданного размера
 * @param size указатель на размер массива (вычисляется случайно)
 *
 * 1. Случайный размер: *size = MIN + rand()/(0..1) * (MAX-MIN)
 * 2. Выделение памяти: malloc(*size * sizeof(double))
 * 3. Заполнение: каждый элемент = -50.0 + 100.0 * rand()/(0..1)
 *
 * Диапазон элементов: [-50.0, +50.0]
 * Размер массива: от MIN до MAX (значения констант)
 *
 * Возвращает указатель на заполненный массив
 */
double* generate_array(int* size);


/**
 * Пузырьковая сортировка массива вещественных чисел по возрастанию
 * @param ptr_array указатель на динамический массив double для сортировки
 * @param n количество элементов в массиве
 *
 * Классическая реализация алгоритма "пузырьком" (bubble sort). Внешний цикл выполняет n-1 проходов.
 * Внутренний цикл сравнивает соседние элементы и меняет их местами, если текущий больше следующего,
 * "всплывая" максимальный элемент к концу отсортированной части. Граница внутреннего цикла
 * `n - i - 1` исключает уже отсортированные элементы. Использует временную переменную double temp
 */
void sort_bubble(double* ptr_array, int n);

/**
 * Сортировка выбором массива вещественных чисел по убыванию
 * @param ptr_array указатель на динамический массив double для сортировки
 * @param n количество элементов в массиве
 * Внешний цикл выполняет n-1 итераций. На каждой итерации
 * во внутреннем цикле ищется индекс максимального элемента в неотсортированной части
 * массива (от i+1 до n-1). Найденный максимум обменивается с первым элементом неотсортированной
 * части (ptr_array[i]). Обмен выполняется только при imax != i для оптимизации.
 * После i-й итерации первые i+1 элементов отсортированы по убыванию.
 */
void sort_select(double* ptr_array, int n);

/**
 * Сортировка вставками массива вещественных чисел по возрастанию
 * @param ptr_array указатель на динамический массив double для сортировки
 * @param n количество элементов в массиве
 *
 * Классическая сортировка вставками. Внешний цикл начиная со второго элемента (i=1) до n-1.
 * Для каждого ptr_array[i] значение сохраняется в temp, затем во внутреннем цикле while
 * сдвигаются вправо все элементы отсортированной части массива (0..i-1), большие temp.
 * Цикл while продолжается пока j>0 и предыдущий элемент больше temp. Вставка происходит
 * на позицию j. После i-й итерации первые i+1 элементов отсортированы.
 */
void sort_insert(double* ptr_array, int n);

/**
 * Шейкерная (коктейльная) сортировка массива double по возрастанию
 * @param arr указатель на массив double
 * @param size количество элементов
 *
 * Улучшенная пузырьковая сортировка. Границы неотсортированной части:
 * left=0 (начало), right=size-1 (конец).
 *
 * Цикл do-while: пока есть обмены и left < right.
 *
 * 1. Проход слева направо: максимумы "всплывают" вправо, right-- при обмене
 * 2. Проход справа налево: минимумы "опускаются" влево, left++ при обмене
 *
 * После прохода отсортированная часть растет с обоих концов.
 */
void sort_cocktail(double* arr, int size);
#endif
